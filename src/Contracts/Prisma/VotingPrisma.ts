/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "../common";

export declare namespace AdminVoting {
  export type ActionStruct = { target: string; data: BytesLike };

  export type ActionStructOutput = [string, string] & {
    target: string;
    data: string;
  };
}

export interface VotingPrismaInterface extends utils.Interface {
  functions: {
    "BOOTSTRAP_FINISH()": FunctionFragment;
    "MAX_PCT()": FunctionFragment;
    "MAX_TIME_TO_EXECUTION()": FunctionFragment;
    "MIN_TIME_BETWEEN_PROPOSALS()": FunctionFragment;
    "MIN_TIME_TO_EXECUTION()": FunctionFragment;
    "SET_GUARDIAN_PASSING_PCT()": FunctionFragment;
    "VOTING_PERIOD()": FunctionFragment;
    "acceptTransferOwnership()": FunctionFragment;
    "accountVoteWeights(address,uint256)": FunctionFragment;
    "cancelProposal(uint256)": FunctionFragment;
    "createNewProposal(address,(address,bytes)[])": FunctionFragment;
    "executeProposal(uint256)": FunctionFragment;
    "getProposalCount()": FunctionFragment;
    "getProposalData(uint256)": FunctionFragment;
    "getWeek()": FunctionFragment;
    "isApprovedDelegate(address,address)": FunctionFragment;
    "latestProposalTimestamp(address)": FunctionFragment;
    "minCreateProposalPct()": FunctionFragment;
    "minCreateProposalWeight()": FunctionFragment;
    "passingPct()": FunctionFragment;
    "prismaCore()": FunctionFragment;
    "setDelegateApproval(address,bool)": FunctionFragment;
    "setMinCreateProposalPct(uint256)": FunctionFragment;
    "setPassingPct(uint256)": FunctionFragment;
    "tokenLocker()": FunctionFragment;
    "voteForProposal(address,uint256,uint256)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "BOOTSTRAP_FINISH"
      | "MAX_PCT"
      | "MAX_TIME_TO_EXECUTION"
      | "MIN_TIME_BETWEEN_PROPOSALS"
      | "MIN_TIME_TO_EXECUTION"
      | "SET_GUARDIAN_PASSING_PCT"
      | "VOTING_PERIOD"
      | "acceptTransferOwnership"
      | "accountVoteWeights"
      | "cancelProposal"
      | "createNewProposal"
      | "executeProposal"
      | "getProposalCount"
      | "getProposalData"
      | "getWeek"
      | "isApprovedDelegate"
      | "latestProposalTimestamp"
      | "minCreateProposalPct"
      | "minCreateProposalWeight"
      | "passingPct"
      | "prismaCore"
      | "setDelegateApproval"
      | "setMinCreateProposalPct"
      | "setPassingPct"
      | "tokenLocker"
      | "voteForProposal"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "BOOTSTRAP_FINISH",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "MAX_PCT", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "MAX_TIME_TO_EXECUTION",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "MIN_TIME_BETWEEN_PROPOSALS",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "MIN_TIME_TO_EXECUTION",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "SET_GUARDIAN_PASSING_PCT",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "VOTING_PERIOD",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "acceptTransferOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "accountVoteWeights",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelProposal",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "createNewProposal",
    values: [string, AdminVoting.ActionStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "executeProposal",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getProposalCount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getProposalData",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "getWeek", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "isApprovedDelegate",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "latestProposalTimestamp",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "minCreateProposalPct",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "minCreateProposalWeight",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "passingPct",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "prismaCore",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "setDelegateApproval",
    values: [string, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "setMinCreateProposalPct",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setPassingPct",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "tokenLocker",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "voteForProposal",
    values: [string, BigNumberish, BigNumberish]
  ): string;

  decodeFunctionResult(
    functionFragment: "BOOTSTRAP_FINISH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "MAX_PCT", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "MAX_TIME_TO_EXECUTION",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "MIN_TIME_BETWEEN_PROPOSALS",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "MIN_TIME_TO_EXECUTION",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "SET_GUARDIAN_PASSING_PCT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "VOTING_PERIOD",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "acceptTransferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "accountVoteWeights",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelProposal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createNewProposal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executeProposal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getProposalCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getProposalData",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getWeek", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isApprovedDelegate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "latestProposalTimestamp",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "minCreateProposalPct",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "minCreateProposalWeight",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "passingPct", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "prismaCore", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setDelegateApproval",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setMinCreateProposalPct",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setPassingPct",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tokenLocker",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "voteForProposal",
    data: BytesLike
  ): Result;

  events: {
    "ProposalCancelled(uint256)": EventFragment;
    "ProposalCreated(address,uint256,(address,bytes)[],uint256,uint256)": EventFragment;
    "ProposalCreationMinPctSet(uint256)": EventFragment;
    "ProposalExecuted(uint256)": EventFragment;
    "ProposalHasMetQuorum(uint256,uint256)": EventFragment;
    "ProposalPassingPctSet(uint256)": EventFragment;
    "VoteCast(address,uint256,uint256,uint256,bool)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "ProposalCancelled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ProposalCreated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ProposalCreationMinPctSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ProposalExecuted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ProposalHasMetQuorum"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ProposalPassingPctSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "VoteCast"): EventFragment;
}

export interface ProposalCancelledEventObject {
  proposalId: BigNumber;
}
export type ProposalCancelledEvent = TypedEvent<
  [BigNumber],
  ProposalCancelledEventObject
>;

export type ProposalCancelledEventFilter =
  TypedEventFilter<ProposalCancelledEvent>;

export interface ProposalCreatedEventObject {
  account: string;
  proposalId: BigNumber;
  payload: AdminVoting.ActionStructOutput[];
  week: BigNumber;
  requiredWeight: BigNumber;
}
export type ProposalCreatedEvent = TypedEvent<
  [string, BigNumber, AdminVoting.ActionStructOutput[], BigNumber, BigNumber],
  ProposalCreatedEventObject
>;

export type ProposalCreatedEventFilter = TypedEventFilter<ProposalCreatedEvent>;

export interface ProposalCreationMinPctSetEventObject {
  weight: BigNumber;
}
export type ProposalCreationMinPctSetEvent = TypedEvent<
  [BigNumber],
  ProposalCreationMinPctSetEventObject
>;

export type ProposalCreationMinPctSetEventFilter =
  TypedEventFilter<ProposalCreationMinPctSetEvent>;

export interface ProposalExecutedEventObject {
  proposalId: BigNumber;
}
export type ProposalExecutedEvent = TypedEvent<
  [BigNumber],
  ProposalExecutedEventObject
>;

export type ProposalExecutedEventFilter =
  TypedEventFilter<ProposalExecutedEvent>;

export interface ProposalHasMetQuorumEventObject {
  id: BigNumber;
  canExecuteAfter: BigNumber;
}
export type ProposalHasMetQuorumEvent = TypedEvent<
  [BigNumber, BigNumber],
  ProposalHasMetQuorumEventObject
>;

export type ProposalHasMetQuorumEventFilter =
  TypedEventFilter<ProposalHasMetQuorumEvent>;

export interface ProposalPassingPctSetEventObject {
  pct: BigNumber;
}
export type ProposalPassingPctSetEvent = TypedEvent<
  [BigNumber],
  ProposalPassingPctSetEventObject
>;

export type ProposalPassingPctSetEventFilter =
  TypedEventFilter<ProposalPassingPctSetEvent>;

export interface VoteCastEventObject {
  account: string;
  id: BigNumber;
  weight: BigNumber;
  proposalCurrentWeight: BigNumber;
  hasPassed: boolean;
}
export type VoteCastEvent = TypedEvent<
  [string, BigNumber, BigNumber, BigNumber, boolean],
  VoteCastEventObject
>;

export type VoteCastEventFilter = TypedEventFilter<VoteCastEvent>;

export interface VotingPrisma extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: VotingPrismaInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    BOOTSTRAP_FINISH(overrides?: CallOverrides): Promise<[BigNumber]>;

    MAX_PCT(overrides?: CallOverrides): Promise<[BigNumber]>;

    MAX_TIME_TO_EXECUTION(overrides?: CallOverrides): Promise<[BigNumber]>;

    MIN_TIME_BETWEEN_PROPOSALS(overrides?: CallOverrides): Promise<[BigNumber]>;

    MIN_TIME_TO_EXECUTION(overrides?: CallOverrides): Promise<[BigNumber]>;

    SET_GUARDIAN_PASSING_PCT(overrides?: CallOverrides): Promise<[BigNumber]>;

    VOTING_PERIOD(overrides?: CallOverrides): Promise<[BigNumber]>;

    acceptTransferOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    accountVoteWeights(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    cancelProposal(
      id: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    createNewProposal(
      account: string,
      payload: AdminVoting.ActionStruct[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    executeProposal(
      id: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    getProposalCount(overrides?: CallOverrides): Promise<[BigNumber]>;

    getProposalData(
      id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        boolean,
        boolean,
        AdminVoting.ActionStructOutput[]
      ] & {
        week: BigNumber;
        createdAt: BigNumber;
        currentWeight: BigNumber;
        requiredWeight: BigNumber;
        canExecuteAfter: BigNumber;
        executed: boolean;
        canExecute: boolean;
        payload: AdminVoting.ActionStructOutput[];
      }
    >;

    getWeek(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { week: BigNumber }>;

    isApprovedDelegate(
      owner: string,
      caller: string,
      overrides?: CallOverrides
    ): Promise<[boolean] & { isApproved: boolean }>;

    latestProposalTimestamp(
      account: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { timestamp: BigNumber }>;

    minCreateProposalPct(overrides?: CallOverrides): Promise<[BigNumber]>;

    minCreateProposalWeight(overrides?: CallOverrides): Promise<[BigNumber]>;

    passingPct(overrides?: CallOverrides): Promise<[BigNumber]>;

    prismaCore(overrides?: CallOverrides): Promise<[string]>;

    setDelegateApproval(
      _delegate: string,
      _isApproved: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    setMinCreateProposalPct(
      pct: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    setPassingPct(
      pct: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    tokenLocker(overrides?: CallOverrides): Promise<[string]>;

    voteForProposal(
      account: string,
      id: BigNumberish,
      weight: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;
  };

  BOOTSTRAP_FINISH(overrides?: CallOverrides): Promise<BigNumber>;

  MAX_PCT(overrides?: CallOverrides): Promise<BigNumber>;

  MAX_TIME_TO_EXECUTION(overrides?: CallOverrides): Promise<BigNumber>;

  MIN_TIME_BETWEEN_PROPOSALS(overrides?: CallOverrides): Promise<BigNumber>;

  MIN_TIME_TO_EXECUTION(overrides?: CallOverrides): Promise<BigNumber>;

  SET_GUARDIAN_PASSING_PCT(overrides?: CallOverrides): Promise<BigNumber>;

  VOTING_PERIOD(overrides?: CallOverrides): Promise<BigNumber>;

  acceptTransferOwnership(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  accountVoteWeights(
    arg0: string,
    arg1: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  cancelProposal(
    id: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  createNewProposal(
    account: string,
    payload: AdminVoting.ActionStruct[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  executeProposal(
    id: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  getProposalCount(overrides?: CallOverrides): Promise<BigNumber>;

  getProposalData(
    id: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      boolean,
      boolean,
      AdminVoting.ActionStructOutput[]
    ] & {
      week: BigNumber;
      createdAt: BigNumber;
      currentWeight: BigNumber;
      requiredWeight: BigNumber;
      canExecuteAfter: BigNumber;
      executed: boolean;
      canExecute: boolean;
      payload: AdminVoting.ActionStructOutput[];
    }
  >;

  getWeek(overrides?: CallOverrides): Promise<BigNumber>;

  isApprovedDelegate(
    owner: string,
    caller: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  latestProposalTimestamp(
    account: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  minCreateProposalPct(overrides?: CallOverrides): Promise<BigNumber>;

  minCreateProposalWeight(overrides?: CallOverrides): Promise<BigNumber>;

  passingPct(overrides?: CallOverrides): Promise<BigNumber>;

  prismaCore(overrides?: CallOverrides): Promise<string>;

  setDelegateApproval(
    _delegate: string,
    _isApproved: boolean,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  setMinCreateProposalPct(
    pct: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  setPassingPct(
    pct: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  tokenLocker(overrides?: CallOverrides): Promise<string>;

  voteForProposal(
    account: string,
    id: BigNumberish,
    weight: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  callStatic: {
    BOOTSTRAP_FINISH(overrides?: CallOverrides): Promise<BigNumber>;

    MAX_PCT(overrides?: CallOverrides): Promise<BigNumber>;

    MAX_TIME_TO_EXECUTION(overrides?: CallOverrides): Promise<BigNumber>;

    MIN_TIME_BETWEEN_PROPOSALS(overrides?: CallOverrides): Promise<BigNumber>;

    MIN_TIME_TO_EXECUTION(overrides?: CallOverrides): Promise<BigNumber>;

    SET_GUARDIAN_PASSING_PCT(overrides?: CallOverrides): Promise<BigNumber>;

    VOTING_PERIOD(overrides?: CallOverrides): Promise<BigNumber>;

    acceptTransferOwnership(overrides?: CallOverrides): Promise<void>;

    accountVoteWeights(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    cancelProposal(id: BigNumberish, overrides?: CallOverrides): Promise<void>;

    createNewProposal(
      account: string,
      payload: AdminVoting.ActionStruct[],
      overrides?: CallOverrides
    ): Promise<void>;

    executeProposal(id: BigNumberish, overrides?: CallOverrides): Promise<void>;

    getProposalCount(overrides?: CallOverrides): Promise<BigNumber>;

    getProposalData(
      id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        boolean,
        boolean,
        AdminVoting.ActionStructOutput[]
      ] & {
        week: BigNumber;
        createdAt: BigNumber;
        currentWeight: BigNumber;
        requiredWeight: BigNumber;
        canExecuteAfter: BigNumber;
        executed: boolean;
        canExecute: boolean;
        payload: AdminVoting.ActionStructOutput[];
      }
    >;

    getWeek(overrides?: CallOverrides): Promise<BigNumber>;

    isApprovedDelegate(
      owner: string,
      caller: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    latestProposalTimestamp(
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    minCreateProposalPct(overrides?: CallOverrides): Promise<BigNumber>;

    minCreateProposalWeight(overrides?: CallOverrides): Promise<BigNumber>;

    passingPct(overrides?: CallOverrides): Promise<BigNumber>;

    prismaCore(overrides?: CallOverrides): Promise<string>;

    setDelegateApproval(
      _delegate: string,
      _isApproved: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    setMinCreateProposalPct(
      pct: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    setPassingPct(
      pct: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    tokenLocker(overrides?: CallOverrides): Promise<string>;

    voteForProposal(
      account: string,
      id: BigNumberish,
      weight: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "ProposalCancelled(uint256)"(
      proposalId?: null
    ): ProposalCancelledEventFilter;
    ProposalCancelled(proposalId?: null): ProposalCancelledEventFilter;

    "ProposalCreated(address,uint256,(address,bytes)[],uint256,uint256)"(
      account?: string | null,
      proposalId?: null,
      payload?: null,
      week?: null,
      requiredWeight?: null
    ): ProposalCreatedEventFilter;
    ProposalCreated(
      account?: string | null,
      proposalId?: null,
      payload?: null,
      week?: null,
      requiredWeight?: null
    ): ProposalCreatedEventFilter;

    "ProposalCreationMinPctSet(uint256)"(
      weight?: null
    ): ProposalCreationMinPctSetEventFilter;
    ProposalCreationMinPctSet(
      weight?: null
    ): ProposalCreationMinPctSetEventFilter;

    "ProposalExecuted(uint256)"(proposalId?: null): ProposalExecutedEventFilter;
    ProposalExecuted(proposalId?: null): ProposalExecutedEventFilter;

    "ProposalHasMetQuorum(uint256,uint256)"(
      id?: null,
      canExecuteAfter?: null
    ): ProposalHasMetQuorumEventFilter;
    ProposalHasMetQuorum(
      id?: null,
      canExecuteAfter?: null
    ): ProposalHasMetQuorumEventFilter;

    "ProposalPassingPctSet(uint256)"(
      pct?: null
    ): ProposalPassingPctSetEventFilter;
    ProposalPassingPctSet(pct?: null): ProposalPassingPctSetEventFilter;

    "VoteCast(address,uint256,uint256,uint256,bool)"(
      account?: string | null,
      id?: BigNumberish | null,
      weight?: null,
      proposalCurrentWeight?: null,
      hasPassed?: null
    ): VoteCastEventFilter;
    VoteCast(
      account?: string | null,
      id?: BigNumberish | null,
      weight?: null,
      proposalCurrentWeight?: null,
      hasPassed?: null
    ): VoteCastEventFilter;
  };

  estimateGas: {
    BOOTSTRAP_FINISH(overrides?: CallOverrides): Promise<BigNumber>;

    MAX_PCT(overrides?: CallOverrides): Promise<BigNumber>;

    MAX_TIME_TO_EXECUTION(overrides?: CallOverrides): Promise<BigNumber>;

    MIN_TIME_BETWEEN_PROPOSALS(overrides?: CallOverrides): Promise<BigNumber>;

    MIN_TIME_TO_EXECUTION(overrides?: CallOverrides): Promise<BigNumber>;

    SET_GUARDIAN_PASSING_PCT(overrides?: CallOverrides): Promise<BigNumber>;

    VOTING_PERIOD(overrides?: CallOverrides): Promise<BigNumber>;

    acceptTransferOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    accountVoteWeights(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    cancelProposal(
      id: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    createNewProposal(
      account: string,
      payload: AdminVoting.ActionStruct[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    executeProposal(
      id: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    getProposalCount(overrides?: CallOverrides): Promise<BigNumber>;

    getProposalData(
      id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getWeek(overrides?: CallOverrides): Promise<BigNumber>;

    isApprovedDelegate(
      owner: string,
      caller: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    latestProposalTimestamp(
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    minCreateProposalPct(overrides?: CallOverrides): Promise<BigNumber>;

    minCreateProposalWeight(overrides?: CallOverrides): Promise<BigNumber>;

    passingPct(overrides?: CallOverrides): Promise<BigNumber>;

    prismaCore(overrides?: CallOverrides): Promise<BigNumber>;

    setDelegateApproval(
      _delegate: string,
      _isApproved: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    setMinCreateProposalPct(
      pct: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    setPassingPct(
      pct: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    tokenLocker(overrides?: CallOverrides): Promise<BigNumber>;

    voteForProposal(
      account: string,
      id: BigNumberish,
      weight: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    BOOTSTRAP_FINISH(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    MAX_PCT(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    MAX_TIME_TO_EXECUTION(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    MIN_TIME_BETWEEN_PROPOSALS(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    MIN_TIME_TO_EXECUTION(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    SET_GUARDIAN_PASSING_PCT(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    VOTING_PERIOD(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    acceptTransferOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    accountVoteWeights(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    cancelProposal(
      id: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    createNewProposal(
      account: string,
      payload: AdminVoting.ActionStruct[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    executeProposal(
      id: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    getProposalCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getProposalData(
      id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getWeek(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isApprovedDelegate(
      owner: string,
      caller: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    latestProposalTimestamp(
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    minCreateProposalPct(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    minCreateProposalWeight(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    passingPct(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    prismaCore(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setDelegateApproval(
      _delegate: string,
      _isApproved: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    setMinCreateProposalPct(
      pct: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    setPassingPct(
      pct: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    tokenLocker(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    voteForProposal(
      account: string,
      id: BigNumberish,
      weight: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;
  };
}
